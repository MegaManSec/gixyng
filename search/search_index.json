{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GixyNG: NGINX Security Scanner &amp; Configuration Checker for Security Audits","text":""},{"location":"#overview","title":"Overview","text":"<p>GixyNG is an open source NGINX configuration security scanner and hardening tool that performs static analysis of your nginx.conf to detect security misconfigurations, hardening gaps, and common performance pitfalls before they reach production. Run it locally or in CI/CD to automate NGINX security audits and configuration compliance checks, producing actionable findings that help prevent unstable/slow NGINX servers, and reduce risk from unsafe directives and insecure defaults.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>GixyNG (the <code>gixy</code> CLI) is distributed on PyPI. You can install it with pip or uv:</p> <pre><code># pip\npip install GixyNG\n\n# uv\nuv tool install GixyNG\n</code></pre> <p>You can also export your NGINX configuration to a single dump file:</p> <pre><code># Dumps the full NGINX configuration into a single file (including all includes)\nnginx -T &gt; ./nginx-dump.conf\n</code></pre> <p>And then scan the dump file elsewhere (or via stdin):</p> <pre><code># Equivalent to scanning the full rendered configuration output.\ngixy ./nginx-dump.conf\n\n# Equivalent to above\ncat ./nginx-dump.conf | gixy -\n</code></pre>"},{"location":"#what-it-can-do","title":"What it can do","text":"<p>GixyNG can detect a wide range of NGINX security and performance misconfigurations across <code>nginx.conf</code> and included configuration files. The following plugins are supported:</p> <ul> <li>[add_header_content_type] Setting Content-Type via add_header</li> <li>[add_header_multiline] Multiline response headers</li> <li>[add_header_redefinition] Redefining of response headers by \"add_header\" directive</li> <li>[alias_traversal] Path traversal via misconfigured alias</li> <li>[allow_without_deny] Allow specified without deny</li> <li>[default_server_flag] Missing default_server flag</li> <li>[error_log_off] <code>error_log</code> set to <code>off</code></li> <li>[hash_without_default] Missing default in hash blocks</li> <li>[host_spoofing] Request's Host header forgery</li> <li>[http_splitting] HTTP Response Splitting</li> <li>[if_is_evil] If is evil when used in location context</li> <li>[invalid_regex] Invalid regex capture groups</li> <li>[low_keepalive_requests] Low <code>keepalive_requests</code></li> <li>[origins] Problems with referer/origin header validation</li> <li>[proxy_pass_normalized] <code>proxy_pass</code> path normalization issues</li> <li>[regex_redos] Regular expression denial of service (ReDoS)</li> <li>[resolver_external] Using external DNS nameservers</li> <li>[return_bypasses_allow_deny] Return directive bypasses allow/deny restrictions</li> <li>[ssrf] Server Side Request Forgery</li> <li>[try_files_is_evil_too] <code>try_files</code> directive is evil without open_file_cache</li> <li>[unanchored_regex] Unanchored regular expressions</li> <li>[valid_referers] none in valid_referers</li> <li>[version_disclosure] Using insecure values for server_tokens</li> <li>[worker_rlimit_nofile_vs_connections] <code>worker_rlimit_nofile</code> must be at least twice <code>worker_connections</code></li> </ul> <p>Something not detected? Please open an issue on GitHub with what's missing!</p>"},{"location":"#usage-flags","title":"Usage (flags)","text":"<p><code>gixy</code> defaults to reading a system's NGINX configuration from <code>/etc/nginx/nginx.conf</code>. You can also specify the location by passing it to <code>gixy</code>:</p> <pre><code># Analyze the configuration in /opt/nginx.conf\ngixy /opt/nginx.conf\n</code></pre> <p>You can run a focused subset of checks with <code>--tests</code>:</p> <pre><code># Only run these checks\ngixy --tests http_splitting,ssrf,version_disclosure\n</code></pre> <p>Or skip a few noisy checks with <code>--skips</code>:</p> <pre><code># Run everything except these checks\ngixy --skips low_keepalive_requests,worker_rlimit_nofile_vs_connections\n</code></pre> <p>To only report issues of a certain severity or higher, use the compounding <code>-l</code> flag:</p> <pre><code># -l for LOW severity issues and high, -ll for MEDIUM and higher, and -lll for only HIGH severity issues\ngixy -ll\n</code></pre> <p>By default, the output of <code>gixy</code> is ANSI-colored; best viewed in an ANSI-compatible terminal. You can use the <code>--format</code> (<code>-f</code>) flag with the <code>text</code> value to get an uncolored output:</p> <pre><code>$ gixy -f text\n\n==================== Results ===================\n\nProblem: [http_splitting] Possible HTTP-Splitting vulnerability.\nDescription: Using variables that can contain \"\\n\" may lead to http injection.\nAdditional info: https://gixy.io/plugins/http_splitting/\nReason: At least variable \"$action\" can contain \"\\n\"\nPseudo config:\ninclude /etc/nginx/sites/default.conf;\n\n    server {\n\n        location ~ /v1/((?&lt;action&gt;[^.]*)\\.json)?$ {\n            add_header X-Action $action;\n        }\n    }\n\n\n==================== Summary ===================\nTotal issues:\n    Unspecified: 0\n    Low: 0\n    Medium: 0\n    High: 1\n</code></pre> <p>You can also use <code>-f json</code> to get a reproducible, machine-readable JSON output:</p> <pre><code>$ gixy -f json\n[{\"config\":\"\\nserver {\\n\\n\\tlocation ~ /v1/((?&lt;action&gt;[^.]*)\\\\.json)?$ {\\n\\t\\tadd_header X-Action $action;\\n\\t}\\n}\",\"description\":\"Using variables that can contain \\\"\\\\n\\\" or \\\"\\\\r\\\" may lead to http injection.\",\"file\":\"/etc/nginx/nginx.conf\",\"line\":4,\"path\":\"/etc/nginx/nginx.conf\",\"plugin\":\"http_splitting\",\"reason\":\"At least variable \\\"$action\\\" can contain \\\"\\\\n\\\"\",\"reference\":\"https://gixy.io/plugins/http_splitting/\",\"severity\":\"HIGH\",\"summary\":\"Possible HTTP-Splitting vulnerability.\"}]\n</code></pre> <p>More flags for usage can be found by passing <code>--help</code> to <code>gixy</code>. You can also find more information in the Usage Guide.</p>"},{"location":"#configuration-and-plugin-options","title":"Configuration and plugin options","text":"<p>Some plugins expose options which you can set via CLI flags or a configuration file. You can read more about those in the Configuration guide.</p>"},{"location":"#gixyng-for-nginx-security-and-compliance","title":"GixyNG for NGINX security and compliance","text":"<p>Unlike running <code>nginx -t</code> which only checks syntax, GixyNG actually analyzes your configuration and detects unhardened instances and vulnerabilities.</p> <p>With GixyNG, you can perform an automated NGINX configuration security review that can run locally or in CI/CD on every change, whether that be for auditing purposes, compliance, or just general testing.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions to GixyNG are always welcome! You can help us in different ways, such as:</p> <ul> <li>Reporting bugs.</li> <li>Suggesting new plugins for detection.</li> <li>Improving documentation.</li> <li>Fixing, refactoring, improving, and writing new code.</li> </ul> <p>Before submitting any changes in pull requests, please read the contribution guideline document, Contributing to GixyNG.</p> <p>The official homepage of GixyNG is https://gixy.io/. Any changes to documentation in GixyNG will automatically be reflected on that website.</p> <p>The source code can be found at https://github.com/MegaManSec/GixyNG.</p>"},{"location":"#what-is-gixy-background","title":"What is Gixy? (Background)","text":"<p>Gixy is an older NGINX configuration analyzer originally developed by Yandex. GixyNG is a maintained fork of Gixy that adds new checks, performance improvements, hardening suggestions, and support for modern Python and NGINX versions. If you are looking for an NGINX config scanner that is actively maintained, use GixyNG.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>You can run <code>gixy</code> entirely from CLI flags, but a configuration file may also be used to read settings, including output formatting, where to write reports, which checks to run, whether to process <code>include</code> directives, some plugin-specific settings, output severity filtering, and where to look for custom variable drop-ins.</p> <p>If you are looking for day-to-day CLI usage examples, see the Usage Guide.</p>"},{"location":"configuration/#where-config-files-live","title":"Where config files live","text":"<p>By default, <code>gixy</code> looks in these locations (loaded in this order):</p> <ul> <li><code>/etc/gixy/gixy.cfg</code></li> <li><code>~/.config/gixy/gixy.conf</code></li> </ul> <p>You can also point to a specific file:</p> <pre><code># Load gixy configuration file from ./gixy.conf\ngixy --config ./gixy.conf\n</code></pre> <p>And if you want a starting point, you can generate a config file from your current command-line args:</p> <pre><code># Write a gixy configuration file to ./gixy.conf\ngixy --write-config ./gixy.conf\n</code></pre>"},{"location":"configuration/#file-format","title":"File format","text":"<p>The format is intentionally boring:</p> <ul> <li><code>key = value</code></li> <li><code>#</code> starts a comment</li> <li>optional <code>[sections]</code> (mainly used for plugin settings)</li> </ul> <p>Values may be quoted or not, and lists should be comma-separated.</p> <p>Most keys match the long CLI flags with the leading <code>--</code> removed. For example:</p> <ul> <li>CLI: <code>--disable-includes</code></li> <li>Config: <code>disable-includes = true</code></li> </ul> <p><code>[sections]</code> blocks are equivalent to their appended, CLI flag usage. For example, the config equivalent of <code>--add-header-redefinition-headers X-Frame-Options</code> is:</p> <pre><code>[add_header_redefinition]\nheaders = X-Frame-Options\n</code></pre> <p>For non-plugin options, use the <code>[gixy]</code> block:</p> <pre><code>[gixy]\nlevel = 2\n</code></pre>"},{"location":"configuration/#settings-you-can-configure","title":"Settings you can configure","text":"<p>These are the knobs you can set in the config file.</p>"},{"location":"configuration/#level","title":"level","text":"<p>You may set the level of filtering applied to the output of <code>gixy</code>:</p> <pre><code>; Report issues of a given severity level or higher (-l for LOW, -ll for MEDIUM, -lll for HIGH)\nlevel = 2\n</code></pre>"},{"location":"configuration/#format","title":"format","text":"<p>Choose the output format:</p> <pre><code>format = console   # default, colored output\n# format = text    # plain text (no ANSI)\n# format = json    # machine-readable JSON\n</code></pre>"},{"location":"configuration/#output","title":"output","text":"<p>Write results to a file instead of stdout:</p> <pre><code>output = ./gixy-report.json\n</code></pre>"},{"location":"configuration/#debug","title":"debug","text":"<p>Run <code>gixy</code> in debug mode or not:</p> <pre><code>; Turn on debug mode\ndebug = false\n</code></pre>"},{"location":"configuration/#tests","title":"tests","text":"<p>You may wish to only run a specific set of tests:</p> <pre><code>; Comma-separated list of tests to exclusively run\ntests = add_header_redefinition,hash_without_default,http_splitting\n</code></pre>"},{"location":"configuration/#skips","title":"skips","text":"<p>You may wish to skip specific tests:</p> <pre><code>; Comma-separated list of tests to exclusively skip\nskips = proxy_pass_normalized,if_is_evil\n</code></pre>"},{"location":"configuration/#disable-includes","title":"disable-includes","text":"<p>If enabled, <code>include</code> directives do not have their included-files read:</p> <pre><code>; Disable \"include\" directive processing\ndisable-includes = false\n</code></pre>"},{"location":"configuration/#vars-dirs","title":"vars-dirs","text":"<p>Provide directories containing custom variable drop-ins:</p> <pre><code>; Comma-separated list of directories with custom variable drop-ins\nvars-dirs = ./vars,/etc/gixy/vars\n</code></pre> <p>If you do not know what vars-dirs is, you probably do not need it. When you do, the dedicated guide is in Custom Variables &amp; Drop-Ins.</p>"},{"location":"configuration/#minimal-example","title":"Minimal example","text":"<p>A tiny config that skips the <code>low_keepalive_requests</code> test, and saves a JSON-formatted report to <code>gixy-report.json</code>.</p> <pre><code>[gixy]\nformat = json\noutput = ./gixy-report.json\nskips = low_keepalive_requests\n</code></pre> <p>Run it like this:</p> <pre><code># Load gixy configuration file from ./gixy.conf\ngixy --config ./gixy.conf\n</code></pre>"},{"location":"configuration/#plugin-specific-flags","title":"Plugin-specific flags","text":"<p>Most <code>gixy</code> settings are global and work well as shared defaults in a config file. Some plugins also expose their own flags (and those can be set via CLI or via the config file), but the details are specific to each check.</p> <p>If you need to tune a specific plugin, start with its documentation:</p> <ul> <li>add_header_redefinition</li> <li>origins</li> <li>regex_redos</li> </ul>"},{"location":"contributing/","title":"Contributing to GixyNG","text":"<p>This document explains how to contribute meaningful changes to GixyNG that are helpful, reviewable, and maintainable.</p> <p>The official homepage of GixyNG is https://gixy.io/. Any changes to documentation in GixyNG will automatically be reflected on that website.</p> <p>The source code can be found at https://github.com/MegaManSec/GixyNG.</p>"},{"location":"contributing/#general-expectations","title":"General Expectations","text":"<p>When contributing to this repository:</p> <ul> <li>Be intentional. Every file and every line in a PR should exist for a clear reason.</li> <li>Take responsibility for your changes. If it's in your PR, you own it.</li> </ul> <p>Low-quality contributions in the past have included broken code, random files, filler documentation, and changes the contributor did not fully understand. These guidelines exist to avoid repeating those mistakes. Tread carefully.</p> <p>GitHub is the main location for contributing.</p> <ul> <li>Pull requests may be submitted in MegaManSec/GixyNG/pulls.</li> <li>Bug reports, suggestions, and other contributions are best handled in MegaManSec/GixyNG/issues.</li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>All pull requests should:</p> <ul> <li>Clearly explain what the change actually does.</li> <li>Be minimal and scoped to the problem being solved.</li> <li>Contain only files and changes relevant to the PR.</li> </ul> <p>Pull requests must not include:</p> <ul> <li>Temporary files, scratch files, or tool-generated artifacts.</li> <li>Unrelated formatting changes or refactors.</li> <li>Emojis, conversational fluff, or filler content in documentation or comments (be it autogenerated or otherwise). In other words, AI slop.</li> </ul>"},{"location":"contributing/#code-quality-standards","title":"Code Quality Standards","text":"<p>All contributions are expected to meet the same quality bar:</p> <ul> <li>Changes should be easy to review and reason about.</li> <li>Contributors must be able to explain how their code works and why it is correct.</li> </ul> <p>Submitting obviously broken or careless changes will be treated as careless work, regardless of intent.</p>"},{"location":"contributing/#ai-llm-tooling-usage-policy","title":"AI / LLM Tooling Usage Policy","text":"<p>AI tools may be used when contributing to this repository, but they do not change contributor responsibility. If your code AI tool creates low quality code that you attempt to contribute, it means you produce low quality code.</p> <p>When using AI or other automation:</p> <ul> <li>You must fully understand, review, and test all generated or assisted output.</li> <li>You are responsible for correctness, quality, and maintainability.</li> <li>Do not submit copy-pasted output you do not understand.</li> </ul> <p>If AI or automation was used in a material way (i.e. codebase change), you must note it briefly in the pull request description, for example:</p> <ul> <li><code>AI usage: yes</code></li> </ul> <p>You may also wish to include some additional (optional) information such as:</p> <ul> <li>A short note about what was assisted (e.g. \"initial implementation of X\", \"tests for Y\".)</li> <li>Which tool was used (e.g. \"Copilot\", \"Claude\", \"ChatGPT\", etc.)</li> </ul> <p>AI-assisted contributions must meet the same standards as hand-written code:</p> <ul> <li>No broken code.</li> <li>No random files or artifacts.</li> <li>No filler documentation or generic AI text.</li> </ul> <p>Once again, it is noted that using AI assistance is allowed. But if you submit broken code, low quality commits, or content which screams \"this person has no idea what they're doing\", your contributions are likely to be completely rejected, and you are likely to be flamed.</p> <p>This policy was created in response to the extremely low quality changes that were generated and accepted in another Gixy fork., Along with other decisions that reduced the overall effectiveness of the tool and its ability to detect vulnerabilities and misconfigurations in nginx configuration (and overall quality of the codebase), those changes were made without a clear understanding of what the AI-generated code was actually doing, or the actions it was taking. This was the catalyst for creating GixyNG, and more information about this can be read in this blog post.</p> <p>Note: This document was written with the assistance of ChatGPT.</p>"},{"location":"nginx-configuration-checker/","title":"NGINX Config Checker: GixyNG vs nginx -t","text":"<p>When people say \"NGINX configuration checker\", they usually mean one of two things:</p> <ul> <li><code>nginx -t</code> for syntax validation, or</li> <li>A static analyzer like the actively maintained Gixy fork, GixyNG, which focuses on security and best practices and actual runtime behavior.</li> </ul> <p>This page explains how GixyNG complements <code>nginx -t</code>, and how to use it as your NGINX configuration checker in day to day work.</p>"},{"location":"nginx-configuration-checker/#what-nginx-t-actually-checks","title":"What <code>nginx -t</code> actually checks","text":"<p>The built-in <code>nginx -t</code> command is great at catching low level problems:</p> <ul> <li>Syntax errors in configuration files</li> <li>Missing or unreadable include files</li> <li>Some simple directive level issues (unknown directives, bad arguments, etc.)</li> </ul> <p>If <code>nginx -t</code> passes, it means:</p> <ul> <li>NGINX can start or reload successfully</li> <li>Your configuration is syntactically valid</li> </ul> <p>It does not mean:</p> <ul> <li>Your configuration is secure</li> <li>You are following best practices</li> <li>There are no logic or security bugs in complex <code>location</code>, <code>map</code>, <code>proxy_pass</code>, or <code>if</code> blocks</li> </ul> <p>It is a linter for syntax, not a security review.</p>"},{"location":"nginx-configuration-checker/#what-gixyng-adds-as-a-configuration-checker","title":"What GixyNG adds as a configuration checker","text":"<p>GixyNG is an NGINX configuration security checker. It parses your <code>nginx.conf</code> (and all included files) and runs a set of security and correctness checks on top of simple syntax validation.</p> <p>GixyNG can detect issues such as:</p> <ul> <li><code>ssrf</code> \u2013 server side request forgery risks in <code>proxy_pass</code> and similar directives</li> <li><code>http_splitting</code> \u2013 HTTP response splitting via unsafe variables in headers</li> <li><code>host_spoofing</code> \u2013 insecure use of the <code>Host</code> header</li> <li><code>alias_traversal</code> \u2013 path traversal through misconfigured <code>alias</code></li> <li><code>add_header_content_type</code> \u2013 setting <code>Content-Type</code> via <code>add_header</code></li> <li><code>version_disclosure</code> \u2013 leaking NGINX version via <code>server_tokens</code></li> <li><code>unanchored_regex</code> \u2013 regular expressions without anchors in security sensitive places.</li> </ul> <p>In other words:</p> <ul> <li><code>nginx -t</code> answers: Can NGINX load this config?</li> <li>GixyNG answers: Is this config safe and sane?</li> </ul>"},{"location":"nginx-configuration-checker/#quick-start-as-a-configuration-checker","title":"Quick start as a configuration checker","text":"<p>If you have GixyNG installed via <code>pip install gixyng</code>, a basic check looks like this:\u200b</p> <pre><code># Check the default NGINX config (usually /etc/nginx/nginx.conf)\ngixy\n\n# Or specify the path explicitly\ngixy /etc/nginx/nginx.conf\n</code></pre> <p>If you want to scan the nginx config using GixyNG on a system other than that which is running NGINX, you can perform a live-configuration dump, like so:</p> <pre><code># Dump the whole nginx configuration to a single file\nnginx -T &gt; nginx.dump\n\n# Scan the full configuration (all \"include\" files included) with GixyNG\ngixy nginx.dump\n</code></pre> <p>To skip specific checks that you know are noisy for your environment:</p> <pre><code># Skip the HTTP splitting check\ngixy --skips http_splitting /etc/nginx/nginx.conf\n</code></pre> <p>To focus on more serious problems only (depending on how you wire severity flags in GixyNG):</p> <pre><code># Example: only medium and high severity issues\ngixy -ll /etc/nginx/nginx.conf\n</code></pre>"},{"location":"nginx-configuration-checker/#side-by-side-nginx-t-vs-gixyng","title":"Side by side: <code>nginx -t</code> vs GixyNG","text":"Tool Syntax validation Includes / multi file configs Security misconfig checks Best practice checks CI/CD friendly <code>nginx -t</code> Yes Yes No No Sort of GixyNG Parses config Yes Yes Yes (via plugins) Yes <p>They are complementary:</p> <ul> <li>Always run <code>nginx -t</code> before reloads to avoid broken configs.</li> <li>Run GixyNG as your NGINX configuration checker before changes hit production, to catch security and logic issues.</li> </ul>"},{"location":"nginx-configuration-checker/#example-treating-gixyng-as-a-gatekeeper","title":"Example: treating GixyNG as a gatekeeper","text":"<p>A simple manual workflow:</p> <ol> <li> <p>Edit your NGINX configuration.</p> </li> <li> <p>Run GixyNG:</p> </li> </ol> <pre><code>gixy /etc/nginx/nginx.conf\n</code></pre> <ol> <li> <p>Fix any reported issues (especially <code>High</code> and <code>Medium</code> severity).</p> </li> <li> <p>Run <code>nginx -t</code>.</p> </li> <li> <p>Reload NGINX only after both steps succeed.</p> </li> </ol> <p>This way:</p> <ul> <li>GixyNG acts as your NGINX configuration checker and security auditor.</li> <li><code>nginx -t</code> remains the last line of defense against syntax errors.</li> </ul>"},{"location":"nginx-configuration-checker/#when-to-use-each-tool","title":"When to use each tool","text":"<p>Use <code>nginx -t</code> when:</p> <ul> <li>You just edited a configuration file and want to be sure NGINX will start.</li> <li>You are troubleshooting a reload failure.</li> </ul> <p>Use GixyNG when:</p> <ul> <li>You want to perform an NGINX configuration security audit.</li> <li>You are onboarding a new application or team and want to catch common misconfigurations.</li> <li>You are preparing for compliance (PCI DSS, etc) and need a repeatable NGINX security check.</li> </ul> <p>Used together, they give you both correctness and security: one checks that NGINX can read your configuration, the other checks that attackers will not enjoy it.</p>"},{"location":"usage/","title":"Usage","text":"<p>GixyNG ships as the <code>gixy</code> CLI. It statically analyzes NGINX configuration (your <code>nginx.conf</code> plus any files it includes) and reports security and hardening issues, along with a few common performance footguns.</p>"},{"location":"usage/#basic-scan","title":"Basic scan","text":"<p>If you have a standard NGINX install, this is usually enough:</p> <pre><code># By-default scans /etc/nginx/nginx.conf\ngixy\n</code></pre> <p><code>gixy</code> can also read from a specific file, or even from stdin:</p> <pre><code># Scan a specific file\ngixy /opt/nginx/nginx.conf\n\n# pipe into gixy and read from stdin\ncat /opt/nginx/nginx.conf | gixy -\n</code></pre>"},{"location":"usage/#scan-a-rendered-config-dump","title":"Scan a rendered config dump","text":"<p>One of the easiest ways to get consistent results from <code>gixy</code> is to scan the fully rendered configuration that NGINX sees. NGINX can print that with <code>nginx -T</code>.</p> <p>On the machine that has NGINX (or inside your NGINX container):</p> <pre><code># Dump the full rendered NGINX config to a single file\nnginx -T &gt; nginx-dump.conf\n</code></pre> <p>Then you can copy <code>nginx-dump.conf</code> anywhere and scan it there:</p> <pre><code># Scan the NGINX dump file ./nginx-dump.conf\ngixy ./nginx-dump.conf\n</code></pre> <p>This workflow is especially handy when:</p> <ul> <li>Your NGINX config is spread across many <code>include</code> files</li> <li>You want your CI pipeline to scan exactly what NGINX is loading</li> <li>You are auditing production config without giving the scanner direct filesystem access</li> </ul>"},{"location":"usage/#severity-filtering","title":"Severity filtering","text":"<p>By default, <code>gixy</code> reports everything it finds. If you only care about higher-severity issues, use <code>-l</code> repeats:</p> <pre><code># Show LOW severity issues and above\ngixy -l\n\n# Show MEDIUM severity issues and above\ngixy -ll\n\n# Show HIGH severity issues only\ngixy -lll\n</code></pre>"},{"location":"usage/#choose-which-checks-run","title":"Choose which checks run","text":"<p>You can run a focused subset of checks with <code>--tests</code>:</p> <pre><code># Only run these checks\ngixy --tests http_splitting,ssrf,version_disclosure\n</code></pre> <p>Or skip a few noisy checks with <code>--skips</code>:</p> <pre><code># Run everything except these checks\ngixy --skips low_keepalive_requests,worker_rlimit_nofile_vs_connections\n</code></pre>"},{"location":"usage/#output-formats","title":"Output formats","text":"<p><code>gixy</code> can print to the console for humans or emit clean output for tooling:</p> <pre><code># Console (default): colored outputs, readable sections.\ngixy -f console\n\n# Plaintext: readable sections without ANSI color codes.\ngixy -f text\n\n# JSON: Reproducible JSON, best for CI and post-processing.\ngixy -f json\n</code></pre>"},{"location":"usage/#write-reports-to-a-file","title":"Write reports to a file","text":"<p>To save the report instead of printing it:</p> <pre><code># Write plain text output to a file\ngixy -f text -o gixy-report.txt\n\n# Write JSON output to a file\ngixy -f json -o gixy-report.json\n</code></pre>"},{"location":"usage/#debug-mode","title":"Debug mode","text":"<p>If something looks off (missing includes, weird parsing, unexpected results), debug mode is your friend:</p> <pre><code># Enable debug mode\ngixy --debug\n</code></pre>"},{"location":"usage/#include-processing","title":"Include processing","text":"<p>By default, <code>gixy</code> processes <code>include</code> directives so it can analyze the full config tree. If you want to treat the input file as standalone, you can disable include processing:</p> <pre><code># Do not read any files that are referenced in 'include' directives\ngixy --disable-includes /path/to/nginx.conf\n</code></pre> <p>When scanning a rendered <code>nginx -T</code> dump, leaving includes enabled is usually fine, but disabling them can fix any odd edge cases such as when an include file could not be found on the system the dump was performed on.</p>"},{"location":"usage/#custom-variable-drop-ins","title":"Custom variable drop-ins","text":"<p>If you ever see warnings about unknown variables, you may wish to specify them manually. You can point <code>gixy</code> to a directory containing files which define additional variables:</p> <pre><code># Read all the *.cfg and *.conf files in ./vars,/etc/gixy/vars\ngixy --vars-dirs ./vars,/etc/gixy/vars\n</code></pre> <p>More information about the expected files in these directories can be found in Custom Variables &amp; Drop-Ins.</p>"},{"location":"usage/#using-a-config-file","title":"Using a config file","text":"<p>If you do not want to pass the same flags every time you run <code>gixy</code>, you can load options from a config file:</p> <pre><code># Load gixy configuration file from ./gixy.conf\ngixy --config ./gixy.conf\n</code></pre> <p>You can also generate a config file from your current CLI arguments:</p> <pre><code># Write a gixy configuration file to ./gixy.conf\ngixy --write-config ./gixy.conf\n</code></pre> <p>Full details (including plugin-specific settings) are found in the Configuration Guide.</p>"},{"location":"variables-dropins/","title":"Custom Variables &amp; Drop-ins","text":"<p><code>gixy</code> tries to resolve variables as it analyzes your NGINX config. When it sees a variable it does not recognize, it will warn; not because your config is wrong, but because the scanner cannot safely tell what might flow into that value.</p> <p>This comes up a lot with third-party modules and bespoke setups (for example variables like <code>$brotli_ratio</code>), or when your organization injects variables through templates.</p> <p>Variable drop-ins are the solution to this: you provide a small directory of definitions, and <code>gixy</code> learns what those variables are supposed to look like.</p> <p>Note: If you never see warnings about unknown variables, you probably don't need to use these.</p>"},{"location":"variables-dropins/#enable-drop-ins","title":"Enable drop-ins","text":"<p>Point <code>gixy</code> at one or more directories containing variable definition files.</p> <p>CLI:</p> <pre><code># Read all the *.cfg and *.conf files in /etc/gixy/vars,~/.config/gixy/vars\ngixy --vars-dirs /etc/gixy/vars,~/.config/gixy/vars\n</code></pre> <p>Config file:</p> <pre><code>[gixy]\nvars-dirs = /etc/gixy/vars,~/.config/gixy/vars\n</code></pre> <p><code>gixy</code> will read all files ending in <code>.cfg</code> or <code>.conf</code> inside those directories.</p>"},{"location":"variables-dropins/#file-format","title":"File format","text":"<p>Each non-empty, non-comment line defines one variable:</p> <pre><code>name value\n</code></pre> <p>Variable names must be written without the leading <code>$</code> (for example <code>brotli_ratio</code> matches <code>$brotli_ratio</code> in your NGINX config).</p> <p>A few value styles are supported:</p> <ul> <li> <p>Quoted literals, treated as literal, fixed values: <code>'...'</code> or <code>\"...\"</code>.</p> </li> <li> <p>Regex patterns, treated as regular expressions describing what the value is allowed to contain: <code>r'...'</code> or <code>r\"...\"</code>.</p> </li> <li> <p><code>none</code> or <code>null</code> (case-insensitive), marking the variable as \"non user-controlled\" for the purpose of analysis.</p> </li> </ul> <p>Also:</p> <ul> <li>Blank lines are ignored</li> <li>Lines starting with <code>#</code> or <code>;</code> are ignored</li> <li>You may use <code>name value</code>, <code>name = value</code>, or <code>name: value</code></li> <li>A trailing comma after the value is accepted (handy if you are copy/pasting)</li> </ul>"},{"location":"variables-dropins/#examples","title":"Examples","text":"<pre><code># /etc/gixy/vars/nginx-module-brotli.cfg\nbrotli_ratio none\n\n# /etc/gixy/vars/nginx-module-foo.cfg\nfoo_host \"example.com\"\nfoo_uri  r'/[^\\s]*',\n</code></pre>"},{"location":"variables-dropins/#prefix-variables","title":"Prefix variables","text":"<p>You can define variable prefixes by ending the name with an underscore (<code>_</code>), similar to NGINX built-ins. For example, defining <code>http_</code> will match variables like <code>$http_user_agent</code>, <code>$http_x_forwarded_for</code>, and so on.</p> <pre><code># Treat any $http_* variable as present\nhttp_ r'.+'\n</code></pre>"},{"location":"plugins/add_header_content_type/","title":"[add_header_content_type] Using add_header to set Content-Type","text":""},{"location":"plugins/add_header_content_type/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin looks for configurations that try to set the <code>Content-Type</code> response header using <code>add_header</code>.</p>"},{"location":"plugins/add_header_content_type/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>NGINX can end up sending two <code>Content-Type</code> headers: one from the upstream, and one you added. Different clients handle duplicates differently, and caches may store an unexpected value. If you are trying to set a fallback MIME type for static content, <code>default_type</code> is the right tool.</p>"},{"location":"plugins/add_header_content_type/#bad-configuration","title":"Bad configuration","text":"<pre><code># Adds a second Content-Type if the upstream already sets one\nadd_header Content-Type text/plain;\n</code></pre> <p>If your backend returns <code>Content-Type: application/json</code>, the response may contain both headers.</p>"},{"location":"plugins/add_header_content_type/#better-configuration","title":"Better configuration","text":"<pre><code># Sets the default MIME type for responses that do not already have one\ndefault_type text/plain;\n</code></pre> <p><code>default_type</code> applies when there is no explicit content type, so you avoid duplicates.</p>"},{"location":"plugins/add_header_content_type/#safe-exception","title":"Safe exception","text":"<p>If you are intentionally replacing the upstream header, hide it first and then add your own:</p> <pre><code>proxy_hide_header Content-Type;\nadd_header Content-Type \"application/octet-stream\";\n</code></pre> <p>This pattern removes the upstream <code>Content-Type</code> before adding a new one, so the client sees only a single value.</p>"},{"location":"plugins/add_header_multiline/","title":"[add_header_multiline] Multiline response headers","text":""},{"location":"plugins/add_header_multiline/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin flags response headers that contain a literal newline in the header value. The usual culprits are <code>add_header</code>, <code>more_set_headers</code>, or string values that span multiple lines for readability.</p>"},{"location":"plugins/add_header_multiline/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>Multiline headers are deprecated and not reliably supported by clients. Some browsers and HTTP stacks will reject or truncate the response, and some intermediaries can mis-parse the header stream. In practice, this turns into hard-to-debug compatibility issues.</p>"},{"location":"plugins/add_header_multiline/#bad-configuration","title":"Bad configuration","text":"<pre><code># Multiline header value (contains a newline)\nmore_set_headers 'X-Foo: Bar\n  multiline';\n</code></pre> <p>Even if it \"works\" in a quick test, it is not safe to rely on.</p>"},{"location":"plugins/add_header_multiline/#better-configuration","title":"Better configuration","text":"<p>Keep the configuration readable, but make the actual header value a single line by composing it with variables.</p> <p>Option 1: build the value from separate pieces:</p> <pre><code>set $csp_default \"default-src 'self'\";\nset $csp_script  \"script-src 'self' https://cdn.example.com\";\nset $csp_style   \"style-src 'self' https://cdn.example.com\";\nset $csp_img     \"img-src 'self' data: https://cdn.example.com\";\nset $csp_font    \"font-src 'self' https://cdn.example.com\";\n\nset $csp \"${csp_default}; ${csp_script}; ${csp_style}; ${csp_img}; ${csp_font}\";\nadd_header Content-Security-Policy $csp;\n</code></pre> <p>Option 2: progressive concatenation:</p> <pre><code>set $csp \"default-src 'self'; \";\nset $csp \"${csp}script-src 'self' https://cdn.example.com; \";\nset $csp \"${csp}style-src 'self' https://cdn.example.com; \";\nset $csp \"${csp}img-src 'self' data: https://cdn.example.com; \";\nset $csp \"${csp}font-src 'self'\";\n\nadd_header Content-Security-Policy $csp;\n</code></pre>"},{"location":"plugins/add_header_multiline/#additional-notes","title":"Additional notes","text":"<p>If you are templating configs, watch for accidental newlines inside quoted strings. They look harmless in a text editor, but they still become literal newline characters in the header value.</p>"},{"location":"plugins/add_header_redefinition/","title":"[add_header_redefinition] Redefining response headers with add_header","text":""},{"location":"plugins/add_header_redefinition/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin looks for nested contexts where <code>add_header</code> is used in both places.</p>"},{"location":"plugins/add_header_redefinition/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>add_header</code> follows an all-or-nothing inheritance rule: headers from the previous level are inherited only if there are no <code>add_header</code> directives at the current level. As soon as you add any header in a nested block, you stop inheriting every header defined above it.</p> <p>That is how teams end up with security headers on most pages, but missing on \"just one location\".</p>"},{"location":"plugins/add_header_redefinition/#bad-configuration","title":"Bad configuration","text":"<pre><code>server {\n    add_header X-Frame-Options \"DENY\";\n    add_header X-Content-Type-Options \"nosniff\";\n\n    location /static/ {\n        # Looks harmless, but it drops the two headers above for /static/\n        add_header Cache-Control \"public, max-age=86400\";\n    }\n}\n</code></pre> <p>Requests under <code>/static/</code> will only get <code>Cache-Control</code>, and the security headers vanish.</p>"},{"location":"plugins/add_header_redefinition/#better-configuration","title":"Better configuration","text":"<p>Option 1: keep all headers at one level (often <code>server</code>), and avoid redefining them in child blocks.</p> <pre><code>server {\n    add_header X-Frame-Options \"DENY\";\n    add_header X-Content-Type-Options \"nosniff\";\n    add_header Cache-Control \"public, max-age=86400\";\n}\n</code></pre> <p>Option 2: if you really need headers that vary by location, repeat the important ones in the nested block:</p> <pre><code>server {\n    add_header X-Frame-Options \"DENY\";\n    add_header X-Content-Type-Options \"nosniff\";\n\n    location /static/ {\n        add_header X-Frame-Options \"DENY\";\n        add_header X-Content-Type-Options \"nosniff\";\n        add_header Cache-Control \"public, max-age=86400\";\n    }\n}\n</code></pre>"},{"location":"plugins/add_header_redefinition/#additional-information","title":"Additional information","text":"<p>Recent NGINX versions added <code>add_header_inherit</code> to adjust how <code>add_header</code> inherits across levels. If you have it available, <code>add_header_inherit merge;</code> can help keep a base set of headers while appending per-location headers. The documentation states that for <code>add_header_inherit</code>:</p> <p>The inheritance rules themselves are inherited in a standard way. For example, add_header_inherit merge; specified at the top level will be inherited in all nested levels recursively unless redefined later.</p>"},{"location":"plugins/alias_traversal/","title":"[alias_traversal] Path traversal via misconfigured alias","text":""},{"location":"plugins/alias_traversal/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin flags <code>alias</code> directives where the <code>location</code> prefix and the alias path are not aligned (most commonly: missing a trailing slash on the <code>location</code>).</p>"},{"location":"plugins/alias_traversal/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>With a mismatched <code>location</code>/<code>alias</code> pair, NGINX can build the filesystem path in unexpected ways. Attackers can use crafted paths like <code>/i../</code> to escape the intended directory and read files outside of it.</p>"},{"location":"plugins/alias_traversal/#bad-configuration","title":"Bad configuration","text":"<pre><code># Location does not end with a slash, but alias points to a directory\nlocation /i {\n    alias /data/w3/images/;\n}\n</code></pre> <p>A request to <code>/i../app/config.py</code> may map to <code>/data/w3/app/config.py</code>, which is outside the intended <code>/images/</code> directory.</p>"},{"location":"plugins/alias_traversal/#better-configuration","title":"Better configuration","text":"<p>If the alias points to a directory, make the location look like a directory too:</p> <pre><code>location /i/ {\n    alias /data/w3/images/;\n}\n</code></pre> <p>If you are mapping a single file, use an exact match:</p> <pre><code>location = /i.gif {\n    alias /data/w3/images/i.gif;\n}\n</code></pre>"},{"location":"plugins/allow_without_deny/","title":"[allow_without_deny] allow without deny","text":""},{"location":"plugins/allow_without_deny/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when a block contains one or more <code>allow</code> directives, but does not also enforce a <code>deny</code> (usually <code>deny all;</code>) in the same effective scope.</p>"},{"location":"plugins/allow_without_deny/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>In NGINX, <code>allow</code> does not mean \"only these addresses\". It means \"these addresses are allowed\", but everyone else is still allowed too unless you also deny them somewhere.</p>"},{"location":"plugins/allow_without_deny/#bad-configuration","title":"Bad configuration","text":"<pre><code>location /admin/ {\n    root /var/www/;\n    allow 10.0.0.0/8;\n    # ... no deny\n}\n</code></pre> <p>This allows <code>10.0.0.0/8</code>, but it does not block anything else.</p>"},{"location":"plugins/allow_without_deny/#better-configuration","title":"Better configuration","text":"<pre><code>location /admin/ {\n    root /var/www/;\n    allow 10.0.0.0/8;\n    deny all;\n}\n</code></pre> <p>Now the access policy is unambiguous: allow the private range, deny everyone else.</p>"},{"location":"plugins/allow_without_deny/#additional-notes","title":"Additional notes","text":"<p>If you apply <code>deny all;</code> at a higher level (for example at <code>server</code>), and then selectively allow in a child location, that can also be valid. The important part is that the final effective policy is \"allow some, deny the rest\", not just \"allow some\".</p>"},{"location":"plugins/default_server_flag/","title":"[default_server_flag] Missing default_server on shared listen socket","text":""},{"location":"plugins/default_server_flag/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin reports when multiple <code>server</code> blocks share the same <code>listen</code> address and port, but none of them is marked as <code>default_server</code> (or <code>default</code>).</p>"},{"location":"plugins/default_server_flag/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>When an incoming request does not match any <code>server_name</code>, NGINX still has to pick a server block. Without an explicit default, selection becomes harder to reason about and may change when configs are refactored or include order changes. That can lead to requests landing on the wrong virtual host, exposing unintended content or certificates.</p>"},{"location":"plugins/default_server_flag/#bad-configuration","title":"Bad configuration","text":"<pre><code># HTTP vhosts share :80, but no default_server\nserver {\n    listen 80;\n    server_name a.test;\n\n    return 301 https://a.test$request_uri;\n}\n\nserver {\n    listen 80;\n    server_name b.test;\n\n    return 301 https://b.test$request_uri;\n}\n\n# HTTPS vhosts share :443, but no default_server\nserver {\n    listen 443 ssl;\n    server_name a.test;\n\n    ssl_certificate     /etc/ssl/a.test.crt;\n    ssl_certificate_key /etc/ssl/a.test.key;\n\n    location / { return 200 \"a\\n\"; }\n}\n\nserver {\n    listen 443 ssl;\n    server_name b.test;\n\n    ssl_certificate     /etc/ssl/b.test.crt;\n    ssl_certificate_key /etc/ssl/b.test.key;\n\n    location / { return 200 \"b\\n\"; }\n}\n</code></pre> <p>Requests for an unknown hostname will be handled by whichever server ends up being the default implicitly.</p>"},{"location":"plugins/default_server_flag/#better-configuration","title":"Better configuration","text":"<p>Pick the server you want as the catch-all and mark it explicitly:</p> <pre><code># Explicit default for HTTP :80\nserver {\n    listen 80 default_server;\n    server_name _;\n\n    return 444;\n}\n\n# Explicit default for HTTPS :443\nserver {\n    listen 443 ssl default_server;\n    server_name _;\n\n    # A dedicated/default cert (self-signed or otherwise) for unknown names\n    ssl_certificate     /etc/ssl/default.crt;\n    ssl_certificate_key /etc/ssl/default.key;\n\n    return 444;\n}\n\n# a.test\nserver {\n    listen 80;\n    server_name a.test;\n\n    return 301 https://a.test$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name a.test;\n\n    ssl_certificate     /etc/ssl/a.test.crt;\n    ssl_certificate_key /etc/ssl/a.test.key;\n\n    location / { return 200 \"a\\n\"; }\n}\n\n# b.test\nserver {\n    listen 80;\n    server_name b.test;\n\n    return 301 https://b.test$request_uri;\n}\n\nserver {\n    listen 443 ssl;\n    server_name b.test;\n\n    ssl_certificate     /etc/ssl/b.test.crt;\n    ssl_certificate_key /etc/ssl/b.test.key;\n\n    location / { return 200 \"b\\n\"; }\n}\n</code></pre>"},{"location":"plugins/error_log_off/","title":"[error_log_off] error_log set to off","text":""},{"location":"plugins/error_log_off/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin flags <code>error_log off;</code>.</p>"},{"location":"plugins/error_log_off/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>Unlike <code>access_log</code>, the <code>error_log</code> directive does not support an <code>off</code> parameter. When you write <code>error_log off;</code>, NGINX interprets <code>off</code> as a path and creates a log file named <code>off</code> in the default config directory (often <code>/etc/nginx</code>).</p> <p>That is confusing at best, and at worst it can fill a filesystem you did not expect to be writing to.</p>"},{"location":"plugins/error_log_off/#bad-configuration","title":"Bad configuration","text":"<pre><code>error_log off;\n</code></pre> <p>This does not turn logging off; it just changes the log destination to a file named <code>off</code>.</p>"},{"location":"plugins/error_log_off/#better-configuration","title":"Better configuration","text":"<p>In general, keep error logging enabled. If you have a very specific reason to suppress it, redirect to <code>/dev/null</code> and set a strict level:</p> <pre><code># Disable error logging as much as possible\nerror_log /dev/null emerg;\n</code></pre>"},{"location":"plugins/error_log_off/#additional-notes","title":"Additional notes","text":"<p>NGINX still needs to validate the config during startup/reload. Errors during that phase can be written to the default error log path until the config is fully read. If you need to change the startup log path, use the <code>-e</code> / <code>--error-log-path</code> option when launching NGINX.</p>"},{"location":"plugins/hash_without_default/","title":"[hash_without_default] Missing default in hash blocks (map, geo)","text":""},{"location":"plugins/hash_without_default/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin checks hash-like blocks such as <code>map</code> and <code>geo</code> and warns when they do not define a <code>default</code> value.</p>"},{"location":"plugins/hash_without_default/#map-special-case","title":"Map special-case","text":"<p>For <code>map</code>, the check intentionally ignores a very common pattern:</p> <ul> <li>If a <code>map</code> has exactly one mapping entry and no explicit <code>default</code>, it is often meant to return an empty string for all other inputs.</li> <li>This is frequently used with <code>limit_req</code> / <code>limit_conn</code>, where an empty key disables limits.</li> <li>Requiring an explicit <code>default</code> in that case would add noise.</li> </ul> <p>So, the plugin only warns for <code>map</code> when there are two or more mapping entries and no explicit <code>default</code>.</p>"},{"location":"plugins/hash_without_default/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>A <code>map</code> or <code>geo</code> without a default can leave \"unmatched\" inputs in a surprising state. Depending on how you use the variable later, that can mean:</p> <ul> <li>falling back to an unintended value,</li> <li>skipping security or routing logic,</li> <li>or accidentally allowing a request that should have been denied.</li> </ul> <p>For <code>map</code>, this risk grows as the number of explicit mappings increases (because more cases are being handled, but unmatched inputs still have no defined behavior).</p>"},{"location":"plugins/hash_without_default/#bad-configuration","title":"Bad configuration","text":"<pre><code>map $request_uri $is_admin {\n    /admin 1;\n    /admin/ 1;\n    # no default\n}\n\n# Later:\nif ($is_admin) {\n    allow 10.0.0.0/8;\n}\n</code></pre> <p>If <code>$request_uri</code> does not match, <code>$is_admin</code> may be empty and the surrounding logic may not behave the way you expect.</p>"},{"location":"plugins/hash_without_default/#better-configuration","title":"Better configuration","text":"<p>Pick an explicit default that matches least privilege:</p> <pre><code>map $request_uri $is_admin {\n    default 0;   # not admin unless matched\n    /admin  1;\n    /admin/ 1;\n}\n</code></pre> <p>Same idea for <code>geo</code>:</p> <pre><code>geo $block_client {\n    default 0;        # not blocked unless matched\n    192.0.2.0/24 1;\n}\n</code></pre>"},{"location":"plugins/hash_without_default/#intentional-empty-default-pattern-map","title":"Intentional empty default pattern (map)","text":"<p>Sometimes, an implicit empty result is the goal. A common example is selectively enabling rate limits:</p> <pre><code># Only requests matching /api get a non-empty key (limits apply).\n# Everything else gets an empty key (limits disabled).\nmap $request_uri $limit_key {\n    ~^/api $binary_remote_addr;\n}\n</code></pre> <p>This is why the plugin does not warn on <code>map</code> blocks with a single mapping entry and no explicit <code>default</code>.</p>"},{"location":"plugins/hash_without_default/#additional-notes","title":"Additional notes","text":"<ul> <li>If the variable controls an allow/deny decision, prefer deny-by-default and add allow rules narrowly.</li> <li>For routing decisions, choose a safe fallback upstream and keep it explicit.</li> <li>If you rely on the \"empty disables behavior\" pattern (for example, rate limiting keys), keep the <code>map</code> minimal and document the intent.</li> </ul>"},{"location":"plugins/host_spoofing/","title":"[host_spoofing] Host header forgery","text":""},{"location":"plugins/host_spoofing/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin flags configurations that forward or rely on the raw <code>Host</code> request header via <code>$http_host</code>, especially when it is passed upstream or used to build redirects/URLs.</p>"},{"location":"plugins/host_spoofing/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>$http_host</code> comes directly from the client. Attackers can spoof it, and many applications use the host value for:</p> <ul> <li>absolute URL generation (links in emails, redirects),</li> <li>tenant selection,</li> <li>cache keys.</li> </ul> <p>If the app trusts an attacker-controlled host, you can end up with phishing links, poisoned caches, and in some setups even SSRF-style request routing issues.</p>"},{"location":"plugins/host_spoofing/#bad-configuration","title":"Bad configuration","text":"<pre><code>location / {\n    proxy_set_header Host $http_host;\n    proxy_pass http://backend;\n}\n</code></pre> <p>If a client sends <code>Host: evil.example</code>, the upstream receives it too.</p>"},{"location":"plugins/host_spoofing/#better-configuration","title":"Better configuration","text":"<p>Use <code>$host</code>, and make sure your <code>server_name</code> is strict:</p> <pre><code>server {\n    listen 80 default_server;\n    server_name example.com www.example.com;\n\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://backend;\n    }\n}\n</code></pre> <p><code>$host</code> is normalized by NGINX and tied into virtual host selection.</p>"},{"location":"plugins/host_spoofing/#additional-notes","title":"Additional notes","text":"<p>In general, apply the same rule to any usage of <code>$http_host</code>: it should generally be considered untrusted.</p>"},{"location":"plugins/http_splitting/","title":"[http_splitting] HTTP splitting (CRLF injection)","text":""},{"location":"plugins/http_splitting/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin looks for cases where user-controlled input can end up inside response headers, usually through <code>add_header</code> (or similar) combined with variables that can contain newline characters.</p>"},{"location":"plugins/http_splitting/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>If an attacker can inject <code>\\r\\n</code> into a header value, they can create additional headers or even influence the response body. At a minimum this is a cache poisoning and security header bypass risk, and in the worst case it becomes a response splitting attack against downstream clients.</p>"},{"location":"plugins/http_splitting/#bad-configuration","title":"Bad configuration","text":"<pre><code># $action comes from a regex capture and is inserted into a response header\nlocation ~ /v1/((?&lt;action&gt;[^.]*)\\.json)?$ {\n    add_header X-Action $action;\n}\n</code></pre> <p>If the capture allows newlines (directly, or via normalization/decoding elsewhere), an attacker can turn one header into many. For example:</p> <pre><code>GET /v1/see%20below%0d%0ax-crlf-header:injected.json HTTP/1.0\nHost: localhost\n\nHTTP/1.1 200 OK\nServer: nginx/1.11.10\nDate: Mon, 13 Mar 2017 21:21:29 GMT\nContent-Type: application/octet-stream\nContent-Length: 2\nConnection: close\nX-Action: see below\nx-crlf-header:injected\n\nOK\n</code></pre>"},{"location":"plugins/http_splitting/#better-configuration","title":"Better configuration","text":"<p>1) Prefer safer variables (for example <code>$request_uri</code> over <code>$uri</code> when you need the raw input).</p> <p>2) Constrain captures so they cannot contain whitespace or control characters:</p> <pre><code># Disallow slashes and whitespace in the capture\nlocation ~ ^/some/(?&lt;action&gt;[^/\\s]+)$ {\n    add_header X-Action $action;\n}\n</code></pre> <p>3) If you must reflect client input, validate it first and keep the allowed character set tight.</p>"},{"location":"plugins/if_is_evil/","title":"[if_is_evil] If is evil when used in location context","text":""},{"location":"plugins/if_is_evil/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns about <code>if</code> directives placed inside a <code>location</code> block.</p>"},{"location":"plugins/if_is_evil/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>if</code> belongs to the rewrite module and is evaluated during the rewrite phase. Inside a <code>location</code>, mixing <code>if</code> with directives from other modules can produce surprising results, including directives being skipped, headers not being set, or in some historical edge cases even crashes. The configuration may look reasonable, but the request processing model is not \"run these directives in order\".</p> <p>The only operations that are considered consistently safe inside an <code>if</code> in a location are:</p> <ul> <li><code>return ...;</code></li> <li><code>rewrite ... last;</code></li> <li><code>rewrite ... redirect;</code></li> <li><code>rewrite ... permanent;</code></li> </ul>"},{"location":"plugins/if_is_evil/#bad-configuration","title":"Bad configuration","text":"<pre><code>location /only-one-if {\n    set $true 1;\n\n    if ($true) {\n        add_header X-First 1;\n    }\n\n    if ($true) {\n        add_header X-Second 1;\n    }\n}\n</code></pre> <p>This is a classic foot-gun: you expect both headers, but you will typically only see one, because <code>add_header</code> is not \"safe\" inside this style of <code>if</code> usage.</p> <p>Another common pitfall:</p> <pre><code>location /if-try-files {\n    try_files /file @fallback;\n\n    set $true 1;\n    if ($true) {\n        # nothing\n    }\n}\n</code></pre> <p>The presence of <code>if</code> can change how the location behaves, and can break things you would not expect to be related.</p>"},{"location":"plugins/if_is_evil/#better-configuration","title":"Better configuration","text":"<p>If your goal is to return early based on a condition, keep it simple and use <code>return</code>:</p> <pre><code>location / {\n    if ($bad) {\n        return 403;\n    }\n\n    # Normal processing continues here\n}\n</code></pre> <p>For anything more complex, move the logic out of <code>if</code>:</p> <ul> <li>use <code>map</code> at <code>http</code> level to compute a variable,</li> <li>or split behavior into separate locations and use <code>error_page</code> with a named location.</li> </ul> <p>Example: choose an alternate handler via a named location:</p> <pre><code>location / {\n    error_page 418 = @other;\n    recursive_error_pages on;\n\n    if ($something) {\n        return 418;\n    }\n\n    # normal handling\n}\n\nlocation @other {\n    # alternate handling\n}\n</code></pre>"},{"location":"plugins/if_is_evil/#additional-notes","title":"Additional notes","text":"<p>If you still want to use <code>if</code> inside a location, treat it as a rewrite-only tool. As soon as you are using it to toggle headers, access rules, proxying, or file handling, you are in the territory where configs become fragile. To read more about \"If Is Evil\", read this page and this page.</p>"},{"location":"plugins/invalid_regex/","title":"[invalid_regex] Using a nonexistent regex capture group","text":""},{"location":"plugins/invalid_regex/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin looks for places where a configuration references <code>$1</code>, <code>$2</code>, and so on, but the regex being used does not actually define that capture group.</p> <p>Common places this shows up:</p> <ul> <li><code>rewrite</code> replacement strings</li> <li><code>set</code> inside an <code>if ($var ~ regex)</code> block</li> <li>patterns that use non-capturing groups like <code>(?:...)</code> or inline modifiers like <code>(?i)</code> and then expect numbered captures</li> </ul>"},{"location":"plugins/invalid_regex/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>NGINX does not throw an error when you reference a missing group. It just substitutes an empty string. That turns into subtle bugs: broken redirects, unexpected paths, or conditions that never match the way you think they do.</p>"},{"location":"plugins/invalid_regex/#bad-configuration","title":"Bad configuration","text":""},{"location":"plugins/invalid_regex/#case-1-modifier-without-a-capture","title":"Case 1: modifier without a capture","text":"<pre><code>rewrite \"(?i)/path\" /$1 break;\n</code></pre> <p><code>(?i)</code> changes matching behavior, but it does not create a capture. There is no <code>$1</code>, so the replacement becomes <code>/</code>.</p>"},{"location":"plugins/invalid_regex/#case-2-no-captures-at-all","title":"Case 2: no captures at all","text":"<pre><code>rewrite \"^/path\" /$1 redirect;\n</code></pre> <p>The pattern has zero capture groups, so <code>$1</code> is always empty.</p>"},{"location":"plugins/invalid_regex/#better-configuration","title":"Better configuration","text":"<p>Either remove the unnecessary capture reference:</p> <pre><code>rewrite \"^/path\" /newpath redirect;\n</code></pre> <p>Or add a capture group if you actually need part of the input:</p> <pre><code>rewrite \"^/path/(.*)$\" /newpath/$1 redirect;\n</code></pre> <p>Same idea inside an <code>if</code>:</p> <pre><code>if ($uri ~ \"^/path/(.*)$\") {\n    set $x $1;\n}\n</code></pre>"},{"location":"plugins/low_keepalive_requests/","title":"[low_keepalive_requests] Low keepalive_requests value","text":""},{"location":"plugins/low_keepalive_requests/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when <code>keepalive_requests</code> is set to an unusually low number.</p>"},{"location":"plugins/low_keepalive_requests/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>keepalive_requests</code> controls how many requests a client can send over a single keep-alive connection before NGINX closes it.</p> <p>Low values create avoidable connection churn:</p> <ul> <li>With HTTP/2, browsers tend to use fewer connections and multiplex many requests. Closing a connection early forces unnecessary reconnects.</li> <li>Some clients will see failed or retried requests when the server closes a busy connection at the wrong time.</li> <li>Extra TLS handshakes and TCP setup cost CPU and latency.</li> </ul> <p>In newer NGINX versions, the default is 1000. Older versions historically used 100.</p>"},{"location":"plugins/low_keepalive_requests/#bad-configuration","title":"Bad configuration","text":"<pre><code>keepalive_requests 100;\n</code></pre> <p>This is often too low for modern browsers and HTTP/2 workloads.</p>"},{"location":"plugins/low_keepalive_requests/#better-configuration","title":"Better configuration","text":"<pre><code>keepalive_requests 1000;\n</code></pre> <p>If your NGINX already defaults to 1000, you can also omit the directive and keep the defaults.</p>"},{"location":"plugins/low_keepalive_requests/#additional-notes","title":"Additional notes","text":"<p>The \"right\" number depends on your traffic and timeouts, but the takeaway is simple: avoid values that force constant reconnecting. If you are tuning performance, look at <code>keepalive_timeout</code> and (for upstream keepalive) the <code>keepalive</code> directive in <code>upstream</code> blocks as well. For more information about when this error can show up, read this post.</p>"},{"location":"plugins/origins/","title":"[origins]: Weak Referer/Origin validation","text":"<p>This check looks for common mistakes when using <code>$http_origin</code> or <code>$http_referer</code> to gate security behavior (CORS, clickjacking headers, etc.). It focuses on regex-based validation in <code>if</code> conditions and in <code>map</code>-based CORS allowlists that reflect an origin into a response header.</p>"},{"location":"plugins/origins/#what-it-detects","title":"What it detects","text":""},{"location":"plugins/origins/#regex-that-can-be-bypassed-to-match-an-untrusted-domain","title":"Regex that can be bypassed to match an untrusted domain","text":"<p>Examples of bypasses this plugin tries to find:</p> <ul> <li>Suffix injection: <code>https://good.example.com.evil.com</code></li> <li>Prefix injection: <code>http://evil.com/?https://good.example.com</code></li> <li>Scheme confusion (when you meant to require https): <code>http://good.example.com</code></li> </ul>"},{"location":"plugins/origins/#invalid-values-that-should-never-be-treated-as-a-valid-originreferer","title":"Invalid values that should never be treated as a valid Origin/Referer","text":"<p>The plugin reports patterns that accept values that are syntactically invalid for the header being validated:</p> <ul> <li>Origin must be: <code>&lt;scheme&gt;://&lt;hostname&gt;[:port]</code> (no path, query, or fragment).</li> <li>Referer should be an absolute URL including scheme and hostname.</li> </ul> <p>It can also flag values that contain uppercase letters or unusual characters in the scheme/host.</p>"},{"location":"plugins/origins/#common-header-typo","title":"Common header typo","text":"<p><code>$http_referrer</code> is not a valid NGINX variable for the HTTP Referer header. The correct variable is <code>$http_referer</code>.</p>"},{"location":"plugins/origins/#why-this-matters","title":"Why this matters","text":"<p>Origin and Referer are attacker-controlled request headers. If your config uses them to decide whether to:</p> <ul> <li>set <code>Access-Control-Allow-Origin</code>,</li> <li>set <code>X-Frame-Options</code> / <code>Content-Security-Policy: frame-ancestors</code>,</li> <li>enable credentials (<code>Access-Control-Allow-Credentials: true</code>),</li> </ul> <p>then a slightly-wrong regex can silently turn a strict policy into \"trust anything that looks kind of right\".</p> <p>Regex allowlists are especially easy to get wrong when you combine:</p> <ul> <li>alternation (<code>|</code>),</li> <li>partial anchoring (<code>^</code> without <code>$</code>, or vice versa),</li> <li>match-any-character dots (<code>.</code>),</li> <li>optional groups,</li> <li>subdomain handling,</li> <li>ports,</li> <li>scheme handling.</li> </ul>"},{"location":"plugins/origins/#what-triggers-a-finding","title":"What triggers a finding","text":"<p>You will typically see findings in these patterns:</p>"},{"location":"plugins/origins/#if-based-validation","title":"<code>if</code>-based validation","text":"<pre><code># Intended: allow only yandex.ru\n# Risk: also matches https://metrika-hacked-yandex.ru/\nif ($http_referer !~ \"^https://([^/])+metrika.*yandex\\.ru/\") {\n    add_header X-Frame-Options SAMEORIGIN;\n}\n</code></pre> <pre><code># Invalid for Origin: origin cannot contain a path\nif ($http_origin !~ \"^https://yandex\\.ru/$\") {\n    add_header X-Frame-Options SAMEORIGIN;\n}\n</code></pre> <pre><code># Wrong variable name (typo)\nif ($http_referrer !~ \"^https://yandex\\.ru/\") {\n    add_header X-Frame-Options SAMEORIGIN;\n}\n</code></pre>"},{"location":"plugins/origins/#map-based-cors-allowlists-that-reflect-an-origin","title":"<code>map</code>-based CORS allowlists that reflect an origin","text":"<p>The plugin also inspects this common pattern:</p> <pre><code># Invalid origin reflected: matches subdomain5example.com\nmap $http_origin $allow_origin {\n    default \"\";\n    ~^https://subdomain.example.com$ $http_origin;\n}\n\nadd_header Access-Control-Allow-Origin $allow_origin always;\n</code></pre> <p>If the <code>map</code> regex can be bypassed (or matches invalid Origin forms), you can end up reflecting a hostile origin.</p>"},{"location":"plugins/origins/#bad-configuration-example","title":"Bad configuration example","text":"<pre><code># Intended to allow only yandex domains, but can also match:\n# https://www.yandex.ru.evil.com\nif ($http_origin ~* ((^https://www\\.yandex\\.ru)|(^https://ya\\.ru)$)) {\n    add_header Access-Control-Allow-Origin \"$http_origin\";\n    add_header Access-Control-Allow-Credentials \"true\";\n}\n</code></pre> <p>Common issues here:</p> <ul> <li>alternation with uneven anchoring,</li> <li>missing <code>$</code> anchors,</li> <li>reflecting <code>$http_origin</code> directly when the allowlist is not strict.</li> </ul>"},{"location":"plugins/origins/#safer-configuration-patterns","title":"Safer configuration patterns","text":""},{"location":"plugins/origins/#prefer-map-with-a-strict-allowlist-and-controlled-reflection","title":"Prefer <code>map</code> with a strict allowlist and controlled reflection","text":"<pre><code>map $http_origin $allow_origin {\n    default \"\";\n\n    # Allow example.com and any subdomain, optional port, https only.\n    ~^https://([A-Za-z0-9-]+\\.)?example\\.com(?::[0-9]{1,5})?$ $http_origin;\n}\n\nadd_header Access-Control-Allow-Origin $allow_origin always;\nadd_header Access-Control-Allow-Credentials \"true\" always;\n</code></pre> <p>Why this is better:</p> <ul> <li>only allowlisted origins are reflected,</li> <li>everything else becomes an empty value,</li> <li>the pattern is fully anchored and describes the full Origin syntax.</li> </ul>"},{"location":"plugins/origins/#keep-origin-rules-strict-origin-has-no-path","title":"Keep Origin rules strict (Origin has no path)","text":"<p>If you need to validate <code>Origin</code>, always anchor the entire value, including any optional port.</p> <p>Good structure to aim for:</p> <ul> <li><code>^https://</code></li> <li>optional subdomain</li> <li>exact registrable domain</li> <li>optional <code>:port</code></li> <li><code>$</code></li> </ul>"},{"location":"plugins/origins/#notes-for-referer-validation","title":"Notes for Referer validation","text":"<p>If your goal is anti-hotlinking or basic referer checks, consider using <code>valid_referers</code> (from <code>ngx_http_referer_module</code>, here) instead of hand-rolled regex in <code>if</code>. It is not perfect, but it is easier to audit than ad-hoc patterns.</p>"},{"location":"plugins/proxy_pass_normalized/","title":"[proxy_pass_normalized] proxy_pass may decode and normalize paths","text":""},{"location":"plugins/proxy_pass_normalized/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when <code>proxy_pass</code> includes a path component, for example <code>proxy_pass http://backend/api/;</code> rather than just <code>proxy_pass http://backend;</code>.</p>"},{"location":"plugins/proxy_pass_normalized/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>When a path is present in <code>proxy_pass</code>, NGINX performs URI processing before proxying. That can include decoding and normalization steps that change what the upstream sees.</p> <p>Typical failure modes:</p> <ul> <li>encoded slashes and dot segments are decoded and normalized (<code>%2F..%2F</code> can become <code>/../</code>)</li> <li>the upstream receives a different path than your access control logic evaluated</li> <li>combined with rewrites, you can get double-encoding or surprising path joins</li> </ul> <p>These issues tend to show up as \"works in the browser, breaks in production\" and in the worst case can turn into traversal/bypass bugs.</p>"},{"location":"plugins/proxy_pass_normalized/#bad-configuration","title":"Bad configuration","text":"<pre><code>location /api/ {\n    # Path included here triggers normalization/decoding behavior\n    proxy_pass http://backend/;\n}\n</code></pre> <p>When a user requests <code>/api/article/..%2F..%2Fuser-uploads%2Fmalicious-file.txt</code>, the backend will see <code>user-uploads/malicious-file.txt</code>.</p>"},{"location":"plugins/proxy_pass_normalized/#better-configuration","title":"Better configuration","text":"<p>If you do not need a fixed prefix, keep proxy_pass host-only:</p> <pre><code>location /api/ {\n    proxy_pass http://backend;\n}\n</code></pre> <p>If you do need to add or reshape the path, do it explicitly using captures so you control what is forwarded, use <code>$request_uri</code>, and use <code>return</code>:</p> <pre><code>location /api/ {\n  rewrite ^ $request_uri;\n  rewrite ^/api(/.*) $1 break;\n  return 400; # extremely important!\n  proxy_pass http://backend/$1;\n}\n</code></pre>"},{"location":"plugins/proxy_pass_normalized/#another-bad-configuration","title":"Another bad configuration","text":"<p>Make sure you do not go from one bad configuration, to another. This is also a bad configuration:</p> <pre><code>location /1/ {\n  rewrite ^ $request_uri;\n  rewrite ^/1(/.*) $1 break;\n  return 400;\n  proxy_pass http://127.0.0.1:8080/\n}\n</code></pre> <p>When a user requests <code>/1/%2F</code>, the backend server will see <code>/%252F</code>.</p>"},{"location":"plugins/proxy_pass_normalized/#another-better-configuration","title":"Another better configuration","text":"<p>Here is another example of a good configuration:</p> <pre><code>location /1/ {\n  rewrite ^ $request_uri;\n  rewrite ^/1(/.*) /special/location$1/folder/ break;\n  return 400; # extremely important!\n  proxy_pass http://127.0.0.1:8080/$1;\n}\n</code></pre> <p>A request made to <code>/1/2</code> will be the the backend server as <code>/special/location/1/2/folder</code>.</p>"},{"location":"plugins/proxy_pass_normalized/#additional-notes","title":"Additional notes","text":"<p>Be careful combining <code>rewrite</code> with a <code>proxy_pass</code> that already has a path. If you are changing the URI, keep it explicit, test with encoded input, and verify what the upstream actually receives. More information can be found in this post.</p>"},{"location":"plugins/regex_redos/","title":"[regex_redos] Regular Expression Denial of Service (ReDoS)","text":""},{"location":"plugins/regex_redos/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin scans regex usage in directives like:</p> <ul> <li><code>location ~ ...</code></li> <li><code>if ($var ~ ...)</code></li> <li><code>rewrite ...</code></li> </ul> <p>and warns about patterns that are likely to cause catastrophic backtracking. This issue is also known as ReDoS.</p>"},{"location":"plugins/regex_redos/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>PCRE-style regex engines can take exponential time on certain inputs when the pattern is ambiguous (nested groups, overlapping alternations, repeated wildcards). With user-controlled input (URI, headers), a single request can burn a lot of CPU in one worker, allowing it to effectively be killed.</p>"},{"location":"plugins/regex_redos/#bad-configuration","title":"Bad configuration","text":"<pre><code># Classic catastrophic backtracking style pattern\nlocation ~ (a+)+$ {\n    return 200 \"ok\";\n}\n</code></pre> <p>A long string of <code>a</code> characters followed by a mismatch can keep the engine backtracking for an extremely long time (many seconds per request).</p>"},{"location":"plugins/regex_redos/#better-configuration","title":"Better configuration","text":"<p>Anchor the pattern, simplify it, and avoid nested quantifiers:</p> <pre><code># Anchored, linear-time for simple inputs\nlocation ~ ^a+$ {\n    return 200 \"ok\";\n}\n</code></pre> <p>General approaches:</p> <ul> <li>use <code>^</code> and <code>$</code> anchors whenever possible,</li> <li>avoid nested <code>(...)+</code> or <code>(.*)+</code> constructs,</li> <li>keep alternations unambiguous,</li> <li>constrain input length before matching expensive patterns.</li> <li>use recheck against any regex patterns used to check for vulnerable expressions.</li> </ul>"},{"location":"plugins/regex_redos/#additional-notes","title":"Additional notes","text":"<p>For more information about issue in nginx, see this post.</p>"},{"location":"plugins/resolver_external/","title":"[resolver_external] Using external DNS nameservers","text":""},{"location":"plugins/resolver_external/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when the <code>resolver</code> directive points to public IPs (for example 1.1.1.1 or 8.8.8.8) instead of a trusted local resolver.</p>"},{"location":"plugins/resolver_external/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>When NGINX uses DNS at request time, it normally caches results. If an attacker can influence DNS responses, they can poison the cache and redirect traffic to an attacker-controlled host. Using public resolvers directly increases the number of hops and parties involved, which increases the chances of getting a bad answer.</p> <p>Various vulnerabilities have been discovered in Nginx's dns resolver, with some of them still unfixed.</p>"},{"location":"plugins/resolver_external/#bad-configuration","title":"Bad configuration","text":"<pre><code># Public resolvers\nresolver 1.1.1.1 8.8.8.8;\n</code></pre>"},{"location":"plugins/resolver_external/#better-configuration","title":"Better configuration","text":"<p>Use a local resolver on loopback that you control (dnsmasq, unbound, systemd-resolved, etc.):</p> <pre><code>resolver 127.0.0.1 [::1] valid=10s;\nresolver_timeout 5s;\n</code></pre>"},{"location":"plugins/return_bypasses_allow_deny/","title":"[return_bypasses_allow_deny] return bypasses allow and deny","text":""},{"location":"plugins/return_bypasses_allow_deny/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when <code>return</code> appears in the same context as <code>allow</code>/<code>deny</code>.</p>"},{"location":"plugins/return_bypasses_allow_deny/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>return</code> runs in the rewrite phase and ends request processing immediately. Access controls (<code>allow</code>/<code>deny</code>) are evaluated later. That means a <code>return</code> placed next to access rules can effectively ignore them, even if the config looks like it should be restricted.</p> <p>In other words: the block reads like \"allow X, deny everyone else\", but the request never actually reaches the access phase: it simply returns unconditionally.</p>"},{"location":"plugins/return_bypasses_allow_deny/#bad-configuration","title":"Bad configuration","text":"<pre><code>location /admin/ {\n    allow 127.0.0.1;\n    deny all;\n\n    # This is evaluated before the access rules above\n    return 200 \"hi\";\n}\n</code></pre> <p>The response is served to everyone, including clients you intended to deny.</p>"},{"location":"plugins/return_bypasses_allow_deny/#better-configuration","title":"Better configuration","text":"<p>If you need to return a response and still enforce allow/deny, move the return into a separate internal handler and put the access rules there:</p> <pre><code>location /admin/ {\n    # Always internally redirect to a named location\n    error_page 418 = @admin_handler;\n    return 418;\n}\n\nlocation @admin_handler {\n    allow 127.0.0.1;\n    deny all;\n\n    return 200 \"hi\";\n}\n</code></pre> <p>Named locations cannot be requested directly by clients, so you can safely concentrate the access rules and the response logic there.</p>"},{"location":"plugins/return_bypasses_allow_deny/#additional-notes","title":"Additional notes","text":"<p>If your goal is simply \"block everyone but X\", prefer expressing it as access control only (for example return 403/444 for everyone else) rather than combining allow/deny with unconditional returns in the same block.</p> <p>For more information about this issue, see this post.</p>"},{"location":"plugins/ssrf/","title":"[ssrf] Server Side Request Forgery","text":""},{"location":"plugins/ssrf/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin looks for <code>proxy_pass</code> usage where the upstream address is built from variables that can be influenced by the client (scheme, host, port, or path). That is the classic NGINX SSRF shape.</p>"},{"location":"plugins/ssrf/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>If an attacker can control where NGINX sends a request, they can:</p> <ul> <li>scan internal networks,</li> <li>reach metadata services,</li> <li>hit admin panels that are not exposed publicly,</li> <li>and in some cases pivot into more serious compromises.</li> </ul> <p>This is especially dangerous when the proxy location is intended to be \"internal\" but can be reached via rewrites, error_page, try_files, or other internal redirects.</p>"},{"location":"plugins/ssrf/#bad-configuration","title":"Bad configuration","text":"<pre><code>location ~* ^/internal-proxy/(?&lt;proxy_proto&gt;https?)/(?&lt;proxy_host&gt;.*?)/(?&lt;proxy_path&gt;.*)$ {\n    internal;\n\n    proxy_pass $proxy_proto://$proxy_host/$proxy_path;\n    proxy_set_header Host $proxy_host;\n}\n</code></pre> <p>Marking a location <code>internal</code> helps, but it does not automatically make the whole setup safe if other directives can route a request into it.</p> <p>A common mistake is combining an unsafe rewrite with the internal proxy:</p> <pre><code>rewrite ^/(.*)/some$ /$1/ last;\n\nlocation ~* ^/internal-proxy/(?&lt;proxy_proto&gt;https?)/(?&lt;proxy_host&gt;.*?)/(?&lt;proxy_path&gt;.*)$ {\n    internal;\n    proxy_pass $proxy_proto://$proxy_host/$proxy_path;\n}\n</code></pre>"},{"location":"plugins/ssrf/#better-configuration","title":"Better configuration","text":"<p>If the set of upstream hosts is small, hardcode them and select with a <code>map</code>:</p> <pre><code>map $arg_target $upstream_host {\n    default \"\";\n    one \"backend1.internal\";\n    two \"backend2.internal\";\n}\n\nserver {\n    location /proxy/ {\n        if ($upstream_host = \"\") { return 400; }\n\n        proxy_pass http://$upstream_host;\n        proxy_set_header Host $upstream_host;\n    }\n}\n</code></pre> <p>If you cannot enumerate hosts, treat the upstream address as a signed token (HMAC) rather than raw client input, and verify it before proxying.</p>"},{"location":"plugins/ssrf/#additional-notes","title":"Additional notes","text":"<p>Variable-based proxying is not inherently insecure, but the moment the variable is derived from user input, you need a tight allowlist and a plan for internal redirect paths (<code>rewrite</code>, <code>error_page</code>, <code>try_files</code>, X-Accel-Redirect, and subrequests).</p>"},{"location":"plugins/try_files_is_evil_too/","title":"[try_files_is_evil_too] try_files without open_file_cache","text":""},{"location":"plugins/try_files_is_evil_too/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when <code>try_files</code> is used, but <code>open_file_cache</code> is not configured.</p>"},{"location":"plugins/try_files_is_evil_too/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>try_files</code> checks the filesystem repeatedly to see whether files exist. Without caching, those checks translate into repeated <code>stat()</code> syscalls. Under load, that adds up quickly and can become one of the hottest spots on a busy server.</p>"},{"location":"plugins/try_files_is_evil_too/#bad-configuration","title":"Bad configuration","text":"<pre><code>location / {\n    try_files $uri $uri/ /index.html;\n}\n</code></pre> <p>This works, but every request may trigger multiple filesystem checks.</p>"},{"location":"plugins/try_files_is_evil_too/#better-configuration","title":"Better configuration","text":"<p>Enable <code>open_file_cache</code> to cache file metadata:</p> <pre><code>open_file_cache          max=10000 inactive=30s;\nopen_file_cache_valid    60s;\nopen_file_cache_min_uses 2;\nopen_file_cache_errors   on;\n\nserver {\n    location / {\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre>"},{"location":"plugins/try_files_is_evil_too/#additional-notes","title":"Additional notes","text":"<p>Caching is not always appropriate. If you serve highly dynamic file trees that change constantly (or you are on a filesystem where metadata caching is risky), you may choose to skip it. If you do, at least be aware of the performance tradeoff and test under realistic load.</p>"},{"location":"plugins/unanchored_regex/","title":"[unanchored_regex] Regular expression without anchors","text":""},{"location":"plugins/unanchored_regex/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin flags regular expressions (commonly in <code>location ~</code> blocks) that are not anchored to the start and/or end of the string.</p>"},{"location":"plugins/unanchored_regex/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>Without anchors, the regex engine can match anywhere inside the input. That has two downsides:</p> <ul> <li>you may match URLs you did not intend to match,</li> <li>the engine has to work harder because it can try many starting positions.</li> </ul>"},{"location":"plugins/unanchored_regex/#bad-configuration","title":"Bad configuration","text":"<pre><code># Matches any URL that contains /v1/ anywhere\nlocation ~ /v1/ {\n    # ...\n}\n</code></pre> <p>Another common example:</p> <pre><code># Matches /foo.php and also /foo.phpanything\nlocation ~ \\.php {\n    # ...\n}\n</code></pre>"},{"location":"plugins/unanchored_regex/#better-configuration","title":"Better configuration","text":"<p>Anchor patterns to reflect what you really mean:</p> <pre><code>location ~ ^/v1/ {\n    # ...\n}\n\nlocation ~ \\.php$ {\n    # ...\n}\n</code></pre>"},{"location":"plugins/valid_referers/","title":"[valid_referers] none in valid_referers","text":""},{"location":"plugins/valid_referers/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin warns when <code>valid_referers</code> includes the <code>none</code> keyword.</p>"},{"location":"plugins/valid_referers/#why-this-is-a-problem","title":"Why this is a problem","text":"<p><code>none</code> means: treat requests with no <code>Referer</code> header as valid.</p> <p>The trouble is that the <code>Referer</code> header is optional. Users and browsers can drop it for perfectly normal reasons (HTTPS to HTTP redirects, referrer policy, opaque origins, <code>data:</code> URLs), and attackers can omit it deliberately. If you accept <code>none</code>, a client can bypass your referer-based control simply by not sending the header.</p>"},{"location":"plugins/valid_referers/#bad-configuration","title":"Bad configuration","text":"<pre><code>valid_referers none server_names *.example.com;\n\nif ($invalid_referer) {\n    return 403;\n}\n</code></pre> <p>With <code>none</code> allowed, a request without <code>Referer</code> will not be considered invalid.</p>"},{"location":"plugins/valid_referers/#better-configuration","title":"Better configuration","text":"<p>If you rely on referer checking, be strict:</p> <pre><code>valid_referers server_names *.example.com;\n\nif ($invalid_referer) {\n    return 403;\n}\n</code></pre> <p>Then decide what you want to do for missing referers. If missing referers must be allowed for user experience, referer validation is not a reliable security boundary for that endpoint.</p>"},{"location":"plugins/valid_referers/#additional-notes","title":"Additional notes","text":"<p>Referer checks are best treated as a friction mechanism (hotlink protection, lightweight clickjacking mitigation), not as any actual security measure.</p>"},{"location":"plugins/version_disclosure/","title":"[version_disclosure] Version disclosure","text":""},{"location":"plugins/version_disclosure/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin checks how <code>server_tokens</code> is configured, and warns when it is explicitly unsafe or when it is missing in a context where it will inherit an unsafe default.</p> <p>It flags:</p> <ul> <li><code>server_tokens on;</code></li> <li><code>server_tokens build;</code></li> <li>missing <code>server_tokens off;</code> in configurations where version disclosure would otherwise occur</li> </ul>"},{"location":"plugins/version_disclosure/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>By default, NGINX includes its version in the <code>Server</code> header and on some error pages. That makes passive fingerprinting easy, and attackers can quickly narrow down known issues for that version.</p> <p>Hiding the version does not fix vulnerabilities, but it removes a free signal.</p>"},{"location":"plugins/version_disclosure/#bad-configuration","title":"Bad configuration","text":"<pre><code>http {\n    server_tokens on;\n}\n</code></pre> <p>Or, more subtly:</p> <pre><code>http {\n    # server_tokens not set here (defaults apply)\n\n    server {\n        listen 80;\n        server_name example.com;\n    }\n}\n</code></pre> <p>If the default in your build exposes the version, every server block inherits that behavior.</p>"},{"location":"plugins/version_disclosure/#better-configuration","title":"Better configuration","text":"<p>Set it once at the top level:</p> <pre><code>http {\n    server_tokens off;\n\n    server {\n        listen 80;\n        server_name example.com;\n    }\n}\n</code></pre>"},{"location":"plugins/worker_rlimit_nofile_vs_connections/","title":"[worker_rlimit_nofile_vs_connections] worker_rlimit_nofile must be at least twice worker_connections","text":""},{"location":"plugins/worker_rlimit_nofile_vs_connections/#what-this-check-looks-for","title":"What this check looks for","text":"<p>This plugin checks the relationship between <code>worker_connections</code> and <code>worker_rlimit_nofile</code> and warns when the file descriptor limit is too low.</p>"},{"location":"plugins/worker_rlimit_nofile_vs_connections/#why-this-is-a-problem","title":"Why this is a problem","text":"<p>NGINX needs file descriptors (FDs) for more than just client connections.</p> <p>Typical FD usage:</p> <ul> <li>Web server mode: 1 FD for the client connection, plus at least 1 FD for the file being served. A single page load can involve multiple files.</li> <li>Proxy mode: 1 FD for the client connection and 1 FD for the upstream connection, plus potentially a temporary file.</li> <li>Caching mode: combines both behaviors (serve cached files, and proxy/cache misses).</li> </ul> <p>If the FD limit is too low, workers will start failing with \"Too many open files\", which shows up as request failures under load.</p>"},{"location":"plugins/worker_rlimit_nofile_vs_connections/#bad-configuration","title":"Bad configuration","text":"<pre><code>worker_connections 4096;\n# Missing or too-low worker_rlimit_nofile\n</code></pre> <p>or:</p> <pre><code>worker_connections 4096;\nworker_rlimit_nofile 4096;\n</code></pre> <p>A 1:1 ratio is often not enough once you account for upstream sockets and files.</p>"},{"location":"plugins/worker_rlimit_nofile_vs_connections/#better-configuration","title":"Better configuration","text":"<p>A practical baseline is at least 2x worker_connections:</p> <pre><code>worker_connections 4096;\nworker_rlimit_nofile 8192;\n</code></pre> <p>Adjust upward if you are proxying heavily, caching, or serving lots of static assets.</p>"},{"location":"plugins/worker_rlimit_nofile_vs_connections/#additional-notes","title":"Additional notes","text":"<p>Also check the OS-level limits (ulimit, systemd unit limits, container limits). Setting <code>worker_rlimit_nofile</code> higher than the process is allowed to use will not help.</p>"}]}